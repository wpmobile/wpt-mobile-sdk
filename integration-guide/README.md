# Integration Guide

> **Note:** The following guide reflects a beta version of the SDK, and is subject to change prior to general availability of the SDK.

* [Introduction](#introduction)
* [Set-up](#set-up)
  * [Pre-requisites](#pre-requisites)
  * [Install the SDK](#install-the-sdk)
  * [Configure the SDK](#configure-the-sdk)
* [Test harness](#test-harness)
* [Registration](#registration)
  * [Register your POS instance](#register-your-pos-instance)
* [Payments](#payments)
  * [Make a payment](#make-a-payment)
  * [Settle a payment](#settle-a-payment)
  * [Cancel a payment](#cancel-a-payment)
  * [Query the last payment result](#query-the-last-payment-result)
  * [Query the last payment receipt](#query-the-last-payment-receipt)
* [Monitoring](#monitoring)
  * [Query IPC status](#query-ipc-status)
  * [Query payment device status](#query-payment-device-status)

## Introduction

The following guide provides a high level walkthrough of integrating the Worldpay Total SDK into your iOS or Android Point of Sale application.

For more information on specific classes, methods and properties, refer to the detailed API reference documentation which can be downloaded for each version of the SDK from [Releases](../releases).

## Set-up

### Pre-requisites

#### iOS

In order to use the Worldpay Total Mobile SDK for iOS, you must meet the following requirements:

* Your project must use **XCode 11.4**
* Your project must target **iOS 9.0** or above
* Swift projects must use **Swift 5.2**

#### Android

In order to use the Worldpay Total Mobile SDK for Android, you must meet the following requirements:

* Your project must have a **minimum Android version of 24** or above
* Your project must have a **target Android version of 29** or above

### Install the SDK

#### iOS

The Worldpay Total Mobile SDK for iOS is provided as a Framework. See [Releases](../releases#ios) for the available versions.

For each target of your app:

1. Add `WorldpayTotalSDK.framework` to *"Frameworks, Libraries, and Embedded Content"*
1. Add the directory you have put the framework file in to *“Framework Search Paths”*, e.g. `$(PROJECT_DIR)/Frameworks/` (recursive)
1. Add the `Dependencies` directory inside the framework file to *“Import Paths”*, e.g. `$(PROJECT_DIR)/Frameworks/WorldpayTotalSDK.framework/Dependencies/` (recursive)

#### Android

The Worldpay Total Mobile SDK for Android is provided as a Maven dependency.

Add the following in the `build.gradle` of your project to specify our Maven repository where the SDK will be downloaded from:

```python
allprojects {
    repositories {
        maven {
            setUrl("http://ec2-34-246-168-118.eu-west-1.compute.amazonaws.com/artifactory/libs-release/")
            credentials {
                username = <username-provided-by-worldpay>
                password = <password-provided-by-worldpay>
            }
        }
    }
}
```

Then define the Worldpay Total Mobile SDK as a dependency for your app by adding the following in the `build.gradle` of your app, setting `<version>` as the version number you require from [Releases](../releases#android):

```python
dependencies {
    compile(name:'com.worldpay:worldpay-total-sdk:<version>')
}
```

### Configure the SDK

Before using the SDK, you must first configure it with the following parameters:

1. The host URL *- this is the URL where your IPC instance has been deployed, this URL should contain:*
   1. *The protocol (`wss://` or `ws://`)*
   1. *The IP address or domain name (e.g. `192.168.1.32`)*
   1. *The port (e.g. `:443`)*
   1. *The context path that the IPC application is running at (e.g. `/ipc-app`)*
1. The connection timeout *- the number of seconds the SDK would wait for a process (such as a payment flow) to complete*
1. A POS License Key *- a unique token that identifies the POS app, this is generated by IPC when registering the POS app. If your POS app is not yet registered, you can pass `null` here and refer to [Register your POS instance](#register-your-pos-instance) for information on how to obtain a POS License Key*
1. A paypoint ID *- the ID of the paypoint configured in IPC that you want to target from this mobile device*
1. Optionally, a custom implementation of `Logger` *- this will allow you to customise how you capture logs from the SDK, by default the SDK uses:*
   1. *Logcat on Android*
   1. *The Unified Logging System for iOS 10 or above*
   1. *The debugger console for iOS 9.x*
1. Basic details of your application (Android only) for logging and traceability

**Swift**
```swift
// Optionally define a custom logger
let logger: Logger? = ...

Configuration.shared.configure(url: "wss://192.168.1.32:443/ipc-app/",
                               timeout: 300,
                               posLicenseKey: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.4Z3CseLRkkmLxat9JI2RYWjHwFSulJQiy8dmiNvdCW4",
                               paypointId: "PAYPOINT_123",
                               logger: logger)
```

**Kotlin**
```kotlin
// Optionally define a custom logger
val logger: Logger? = ...

Configuration.configure("wss://192.168.1.32:443/ipc-app/",
                        300,
                        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.4Z3CseLRkkmLxat9JI2RYWjHwFSulJQiy8dmiNvdCW4",
                        "PAYPOINT_123",
                        logger,
                        AppDetails("My POS Application", "1.0.0"))
```

## Test harness

A test harness is available for the SDK which allows payment flows to be executed without an IPC installation or payment terminals, by simulating typical scenarios.

The SDK test harness is an executable Java application that can be run on a Windows/Linux PC or Mac which the mobile device using the SDK can connect to.

Download the test harness from [Releases](../releases#test-harness), and then run it by executing the following from your command line:

```shell
java -jar worldpay-total-sdk-test-harness-<version>.jar
```

You can check the test harness is running by visiting [http://localhost:8080/actuator/health](http://localhost:8080/actuator/health).

To customise the port that the server runs on, add `--server.port=XXXX` after the jar name in the java command.

You can configure your SDK instance to connect to the test harness (see **Configure the SDK** above) by providing the following values:

* Host URL: `ws://localhost:8080/` (update the hostname and port as appropriate for where you have deployed the test harness)
* Paypoint ID: Any value is accepted by the test harness (e.g. `PAYPOINT_1`)
* POS License Key: `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.4Z3CseLRkkmLxat9JI2RYWjHwFSulJQiy8dmiNvdCW4` (this is a test value accepted only by the test harness)

## Registration

### Register your POS instance

Each instance of you POS app must have a unique POS License Key to be able to interact securely with the IPC.

To register your POS instance you should use the `RegistrationManager.registerPointOfSale` method. If registration is successful, you will receive a POS License Key back which you should use to [re-configure the SDK](#configure-the-sdk), then store this value for future use.

**Swift**
```swift
let responseReceived = { (response: PosRegistrationResponse) in
    // Re-configure the SDK
    
    // Store the POS License Key
}

let errorReceived = { (response: UnhandledError) in
    // Handle error
}

let posRegistrationResponseHandler = PosRegistrationResponseHandler(registerPosResponse: responseReceived,
                                                                    errorResponse: errorReceived)

let posRegistrationRequest = PosRegistration(pointOfSale: PointOfSale(id: "D45FGT",
                                                                      reference: "POS123",
                                                                      activationCode: "AV46THTR"))

RegistrationManager.shared.registerPointOfSale(request: posRegistrationRequest,
                                               handler: posRegistrationResponseHandler)
```

**Kotlin**
```kotlin
val registrationCallback = object : PosRegistrationCallback() {
    override fun onRegistrationComplete(response: PosRegistrationResponse) {
        // Re-configure the SDK
    
        // Store the POS License Key
    }

    override fun onError(error: UnhandledError) {
        // Handle error
    }
}

val posRegistrationRequest = PosRegistration(PointOfSale("D45FGT",
                                                         "POS123",
                                                         "AV46THTR"))

RegistrationManagerCompat.registerPointOfSale(Dispatchers.getIO(),
                                              posRegistrationRequest,
                                              registrationCallback)
```

_If you are familar with Kotlin Coroutines, you can use the `RegistrationManager` class within a `CoroutineScope` instead of using `RegistrationManagerCompat` with callbacks._

## Payments

### Make a payment

The `PaymentManager.startPayment` method supports all types of payments (sale, pre-auth and refund), and all types of payment instrument; card (including present, not present and keyed) and card tokens.

To make a payment, first define the type of payment to make. The types of payment request are:

* `CardSale`
* `CardRefund`
* `CardPreAuthSale`
* `TokenisedCardSale`
* `TokenisedCardRefund`

**Swift**
```swift
let paymentRequest = CardSale(merchantTransactionReference: "12345678AB", // A transaction reference defined by the merchant
                              value: 1099, // The value of the payment, in minor currency units
                              type: .cardPresent) // How the card will be presented
```

**Kotlin**
```kotlin
val paymentRequest = CardSale("12345678AB", // A transaction reference defined by the merchant
                              1099, // The value of the payment, in minor currency units
                              CardInteraction.CARD_PRESENT) // How the card will be presented
```

During the payment flow, a number of real-time responses will be returned to your app by the SDK, these include:

* Zero or more `PaymentNotification` - an update on the progress of the payment
* Zero or more `PaymentAction` - an action is required to be performed by your app, possible actions are:
  * *Perform a voice authorisation - the authorisation code from a voice authorisation must be provided*
  * *Input a cashback amount - the amount of cashback requested by the customer must be provided*
  * *Accept/Decline AVS results - confirmation that the AVS results should be accepted must be provided*
  * *Verify the customer's signature - confirmation that the customer's signature is valid must be provided*
* Two `PaymentReceipt` - the content of a receipt to be printed, these will be customer and merchant copies
* One `PaymentResult` - the final result of the payment, containing the outcome, gateway transaction reference and IDs, and details of the card used
* Confirmation that the payment flow has completed and no more messages will be received

In the event an action is requested, the payment flow will pause until the action is completed and the requested data is provided to the SDK.

To receive these responses, define a `PaymentHandler`:

**Swift**
```swift
let paymentHandler: PaymentResponseHandler

let notificationReceived = { notification in
    // Display the text to the POS operator
}
let receiptReceived = { receipt in
    // Send the receipt content to a printer
}
let resultReceived = { result in
    // Handle the result of the payment, e.g. display on screen, or store the payment data
}
let actionRequired = { action in
    // Perform the action

    // Respond to the action, confirming it is complete with the relevant data
    paymentHandler.sendActionConfirmation(action: actionConfirmation)
}
let paymentComplete = { () in
    // The payment flow has completed, ready to start the next payment
}

let errorReceived = { error in
    // Handle unexpected errors
}

paymentHandler = PaymentResponseHandler(notificationReceived: notificationReceived,
                                        receiptReceived: receiptReceived,
                                        resultReceived: resultReceived,
                                        actionRequired: actionRequired,
                                        paymentComplete: paymentComplete,
                                        errorReceived: errorReceived)
```

**Kotlin**
```kotlin
var paymentHandler: PaymentHandler? = null

val notificationReceived = fun (notification: PaymentNotification) {
    // Display the text to the POS operator
}
val receiptReceived = fun (receipt: PaymentReceipt) {
    // Send the receipt content to a printer
}
val resultReceived = fun (result: PaymentResult) {
    // Handle the result of the payment, e.g. display on screen, or store the payment data
}
val actionRequested = fun (action: PaymentActionRequired) {
    // Perform the action

    // Respond to the action
    paymentHandler?.sendActionConfirmation(actionConfirmation)
}
val paymentComplete = fun () {
    // The payment flow has completed, ready to start the next payment
}

paymentHandler = object : PaymentHandler() {
    override fun onEvent(paymentEvent: PaymentEvent) {
        when (paymentEvent) {
            is PaymentNotification -> notificationReceived(paymentEvent)
            is PaymentReceipt -> receiptReceived(paymentEvent)
            is PaymentResult -> resultReceived(paymentEvent)
            is PaymentActionRequired -> actionRequested(paymentEvent)
            is PaymentComplete -> paymentComplete()
        }
    }

    override fun onErrorReceived(error: UnhandledError) {
        // Handle unexpected errors
    }
}
```

And finally start the payment:

**Swift**
```swift
PaymentManager.shared.startPayment(request: paymentRequest,
                                   handler: paymentHandler)
```

**Kotlin**
```kotlin
PaymentManagerCompat.startPayment(Dispatchers.getIO(),
                                  paymentRequest,
                                  paymentHandler)
```

_If you are familar with Kotlin Coroutines, you can use the `PaymentManager` class within a `CoroutineScope` instead of using `PaymentManagerCompat` with callbacks._

### Abort an in-flight payment

Some payments can be aborted in-flight by the POS, this depends on the type of payment and the state of the payment flow at the time of the abort request. To abort a payment, use the `abortPayment` method on your `PaymentHandler`.

If the payment cannot be aborted then the payment flow will continue uninterrupted. If the payment can be aborted, then the payment flow will return an aborted `PaymentResult` and confirmation that the payment flow has completed.

**Swift**
```swift
paymentHandler?.abortPayment(PaymentAbort(merchantTransactionReference: "12345679AB")) // Confirm the transaction reference from the original payment request
```

**Kotlin**
```kotlin
paymentHandler.abortPayment(PaymentAbort("12345679AB")) // Confirm the transaction reference from the original payment request
```

### Settle a payment

If a pre-auth payment is made using `CardPreAuthSale`, it must later be settled in order for the funds to be transferred to the merchant.

To settle a pre-auth payment, you must have the gateway transaction reference, card expiry date, and card number returned in the result of the pre-auth payment. Optionally, you can provide a speicfic amount to settle if you wish to settle less than the previously authorised amount.

During the settlement flow, the following real-time responses will be returned to your app by the SDK:

* One `PaymentResult` - the final result of the payment, containing the outcome, gateway transaction reference and IDs, and details of the card used
* Confirmation that the settlement flow has completed and no more messages will be received

As with making a payment, define a `PaymentHandler` to receive these responses, then send the settle payment request:

**Swift**
```swift
let paymentHandler = ...

let settleRequest = CardSettlement(
                      value: 1099,
                      gatewayTransactionReference: "98765-4321-DF",
                      cardNumber: "123456XXXXXX1234")
                      CardDate(month: 12, year: 21))

PaymentManager.shared.settlePayment(request: settleRequest,
                                    handler: paymentHandler)
```

**Kotlin**
```kotlin
val paymentHandler = ...

val settleRequest = CardSettlement(
                      1099,
                      "98765-4321-DF",
                      "123456XXXXXX1234"
                      PaymentCardDate(12, 21))

PaymentManagerCompat.settlePayment(Dispatchers.getIO(),
                                   settleRequest,
                                   paymentHandler)
```

_If you are familar with Kotlin Coroutines, you can use the `PaymentManager` class within a `CoroutineScope` instead of using `PaymentManagerCompat` with callbacks._

### Cancel a payment

To cancel a previously made card payment, you must have the gateway transaction reference, card expiry date, and card number returned in the result of the payment you wish to cancel.

During the cancel flow, the following real-time responses will be returned to your app by the SDK:

* Two `PaymentReceipt` - the content of a receipt to be printed, these will be customer and merchant copies
* One `PaymentResult` - the final result of the payment, containing the outcome, gateway transaction reference and IDs, and details of the card used
* Confirmation that the cancel flow has completed and no more messages will be received

As with making and settling a payment, define a `PaymentHandler` to receive these responses, then send the cancel payment request:

**Swift**
```swift
let paymentHandler = ...

let cancelRequest = PaymentCancelRequest(
                      originalGatewayTransactionReference: "98765-4321-DF",
                      PaymentInstrument(cardExpiryDate: PaymentCardDate(month: 12, year: 21),
                                        cardNumber: "123456XXXXXX1234"))

PaymentManager.shared.cancelPayment(request: cancelRequest,
                                    handler: paymentHandler)
```

**Kotlin**
```kotlin
val paymentHandler = ...

val cancelRequest = PaymentCancelRequest("98765-4321-DF",
                                         PaymentInstrument(PaymentCardDate(12, 21),
                                                           "123456XXXXXX1234"))

PaymentManagerCompat.cancelPayment(Dispatchers.getIO(),
                                   cancelRequest,
                                   paymentHandler)
```

_If you are familar with Kotlin Coroutines, you can use the `PaymentManager` class within a `CoroutineScope` instead of using `PaymentManagerCompat` with callbacks._

### Query the last payment result

To query the *result* of the last payment, you should pass the merchant transaction reference of the payment.

During the query flow, the following real-time responses will be returned to your app by the SDK:

* One `PaymentResult` - the final result of the payment, containing the outcome, gateway transaction reference and IDs, and details of the card used

As with making, settling or cancelling a payment, define a `PaymentHandler` to receive these responses, then send the query payment request:

**Swift**
```swift
let paymentHandler = ...

let queryRequest = PaymentResultQuery(merchantTransactionReference: "12345678AB")

PaymentManager.shared.queryPayment(request: queryRequest,
                                   handler: paymentHandler)
```

**Kotlin**
```kotlin
val paymentHandler = ...

val queryRequest = PaymentResultQuery("12345678AB")

PaymentManagerCompat.queryPayment(Dispatchers.getIO(),
                                  queryRequest,
                                  paymentHandler)
```

_If you are familar with Kotlin Coroutines, you can use the `PaymentManager` class within a `CoroutineScope` instead of using `PaymentManagerCompat` with callbacks._

### Query the last payment receipt

To query the *receipt* of the last payment, you should pass the merchant transaction reference of the payment and the type of receipt required.

During the query flow, the following real-time responses will be returned to your app by the SDK:

* One `PaymentReceipt` - the content of a receipt to be printed, these will be the customer or merchant copy, depending on your request

As with making, settling or cancelling a payment, define a `PaymentHandler` to receive these responses, then send the query payment request:

**Swift**
```swift
let paymentHandler = ...

let queryRequest = PaymentReceiptQuery(
                     merchantTransactionReference: "12345678AB"
                     type: .customer)

PaymentManager.shared.queryPayment(request: queryRequest,
                                   handler: paymentHandler)
```

**Kotlin**
```kotlin
val paymentHandler = ...

val queryRequest = PaymentReceiptQuery(
                     "12345678AB",
                     ReceiptType.CUSTOMER)

PaymentManagerCompat.queryPayment(Dispatchers.getIO(),
                                  queryRequest,
                                  paymentHandler)
```

_If you are familar with Kotlin Coroutines, you can use the `PaymentManager` class within a `CoroutineScope` instead of using `PaymentManagerCompat` with callbacks._

## Monitoring

### Query IPC status

At any time, you can query the status of the IPC instance the SDK is connected to to understand if the instance is ready to take a payment.

**Swift**
```swift
let statusReceived = { status in
  // Check the status of IPC
}

let errorReceived = { error in
  // Handle unexpected errors
}

let statusHandler = StatusMonitorResponseHandler(clientStatusResponse: statusReceived,
                                                 errorReceived: errorReceived)

StatusMonitor.shared.getClientStatus(handler: statusHandler)
```

**Kotlin**
```kotlin
val clientStatusCallback = object : ClientStatusCallback() {
    override fun onStatusReceived(paymentClientStatus: PaymentClientStatus) {
        // Check the status of IPC
    }

    override fun onError(error: UnhandledError) {
        // Handle unexpected errors
    }
}

StatusMonitorCompat.getClientStatus(Dispatchers.getIO(),
                                    clientStatusCallback)
```

_If you are familar with Kotlin Coroutines, you can use the `StatusMonitor` class within a `CoroutineScope` instead of using `StatusMonitorCompat` with callbacks._

### Query payment device status

At any time, you can query the status of the payment device associated with your paypoint.

**Swift**
```swift
let statusReceived = { status in
  // Check the status of the payment device
}

let errorReceived = { error in
  // Handle unexpected errors
}

let statusHandler = StatusMonitorResponseHandler(deviceStatusResponse: statusReceived,
                                                 errorReceived: errorReceived)

StatusMonitor.shared.getDeviceStatus(handler: statusHandler)
```

**Kotlin**
```kotlin
val deviceStatusCallback = object : DeviceStatusCallback() {
    override fun onStatusReceived(paymentDeviceStatus: PaymentDeviceStatus) {
        // Check the status of the payment device
    }

    override fun onError(error: UnhandledError) {
        // Handle unexpected errors
    }
}

StatusMonitorCompat.getDeviceStatus(Dispatchers.getIO(),
                                    deviceStatusCallback)
```

_If you are familar with Kotlin Coroutines, you can use the `StatusMonitor` class within a `CoroutineScope` instead of using `StatusMonitorCompat` with callbacks._

###### ©2020 Worldpay, LLC and/or its affiliates. All rights reserved.
